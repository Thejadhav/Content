# -*- coding: utf-8 -*-
"""Diabetes Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y5eNpXa5YxHAzOvs8p8JB-ynkBF1JP6c

**Import Library**
"""

import pandas as pd

import numpy as np

"""**Import CSV as DataFrame**

**Use URL of file directly**
"""

df = pd.read_csv(r'https://github.com/YBI-Foundation/Dataset/raw/main/Diabetes.csv')

"""**Get the First Five Rows Of Dataframe**"""

df.head()

"""**Get Information of DataFrame**"""

df.info()

"""**Get the Summary Statistics**"""

df.describe()

"""**Get Column Names**"""

df.columns

"""**Get Shape of Dataframe**"""

df.shape

"""**Get Unique values (Class or Label) in y Variable**"""

df['diabetes'].value_counts()

df.groupby('diabetes').mean()

"""**Define y (dependent or label or target variable) and X (independent or features or attribute Variable)**"""

y = df['diabetes']

y.shape

y

X = df[['pregnancies','glucose','diastolic','triceps','insulin','bmi','dpf','age']]

"""or use.drop function to define X"""

X = df.drop('diabetes', axis=1)

X.shape

X

"""**Get X variables Standardized**

Standardization of datasets is a common requirement for many machine learning estimators implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with zero mean and unit variance.

Next approach is go for MinMax Scaler
"""

from sklearn.preprocessing import MinMaxScaler

mm = MinMaxScaler()

X = mm.fit_transform(X)

X

"""**Get Train Test Split**"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3, stratify= y, random_state=2529)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

"""**Get Model Train**"""

from sklearn.linear_model import LogisticRegression

lr = LogisticRegression()

lr.fit(X_train, y_train)

"""**Get Model Prediction**"""

y_pred = lr.predict(X_test)

y_pred.shape

y_pred

"""**Get Probability of Each Predicted Class**"""

lr.predict_proba(X_test)

"""**Get Model Evaluation**"""

from sklearn.metrics import confusion_matrix, classification_report

print(confusion_matrix(y_test , y_pred))

print(classification_report(y_test , y_pred))

"""**Get Future Predictions**

**Lets select a random sample from existing dataset as new value or patient**

Steps to follow

1. Extract a random row using sample function

2. Separate X and y

3. Standardize X

4. Predict
"""

X_new = df.sample(1)

X_new

X_new.shape

X_new = X_new.drop('diabetes', axis =1)

X_new

X_new.shape

X_new = mm.fit_transform(X_new)

y_pred_new = lr.predict(X_new)

y_pred_new

lr.predict_proba(X_new)

"""**Predicted and Actual Class is Zero (0) that is Non-Diabetic**"""